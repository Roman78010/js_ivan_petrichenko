"use strict";

console.log('Запрос данных');


// Когда мы создаем Promise`ы обычно callback функция принимает два аргумента: resolve и reject.
const req = new Promise((resolve, reject) => {
  setTimeout(() => {
    console.log('Поготовка данных ...');
  
    const product = {
      name: 'TV',
      price: 2000
    };
    
    resolve(product);
  }, 2000);
});


req.then((product) => {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      product.status = 'order';
      // Что бы поддерживалась связь между данными (переменными) внутри Promise`а и методом then() нужно, какбы возвращать, передававть переменные. В Promise`е мы их передаем в качестве аргумента функции-аргуммента "resolve". И также, как аргумент передаем в then().
      resolve(product);
    }, 2000);
  });
}).then(data => {
  data.modify = true;
  return data;
}).then(data => {
  console.log(data);
}).catch(() => {
  console.error('Произошла ошибка');
}).finally(() => {
  console.log('Finally');
});

// then() - это метод, который выполняется на Promise`е в случае положительного исхода.
// Функцию "resolve" мы помещаем внутрь then`а, как аргумент.

// Мы создаем обещание, которое помещаем внутрь переменной "req". Когда мы создаем обещание мы предпологаем, что оно может завершиться, как положительно так и отрицательно. Определенный промежкток времени, пока мы не получили результат мы незнаем как завершится наше обещание. Аналогично с сервером, мы посылаем запрос на сервер и ждем от него ответа и незнаем какой будет ответ. Аргументы у callback функции "resolve" и "reject" Promise`а по факту это аргументы вместо которых у нас будут подставляться функции.
// Для того что бы обрабатывать положительный результат (пришедший от Promise`) у нас есть метод then(). Он внутри себя принимает тот аргумент с функцией, который называется "resolve".

// При передаче данных от одного then() к другому данные у второго then`а могут именоваться произвольно.
// Цепочка из then`ов обеспечивает четкую последовательность выполнения действий, друг за другом.

// req.then((product) => {
//   const req2 = new Promise((resolve, reject) => {
//     setTimeout(() => {
//       product.status = 'order';
//       // Что бы поддерживалась связь между данными (переменными) внутри Promise`а и методом then() нужно, какбы возвращать, передававть переменные. В Promise`е мы их передаем в качестве аргумента функции-аргуммента "resolve". И также, как аргумент передаем в then().
//       resolve(product);
//     }, 2000);

//   });
//   req2.then(data => {
//     console.log(data);
//   });
// });

// Ошибка от Promise`а может происходить, если мы ссылаемся на несуществущий файл, когда делаем к ниму запрос или на несуществующий сервер, или сервер упал и возвращает ошибку.
// Catch в цепочке действий всегда ставится в конце. Но после него может ставиться метод finally().

// В блок (им. ввиду в callback функцию) then мы можем поместить показ модального окна на страничке, дальше в следующем then`е мы его скрываем, обрабатываем данные и т. д. Если что-то пошло не так у нас срабатывает блок catch, в котором мы говорим пользователю что что-то пошло не так. И остается finally, в это блок мы можем поместить очистку формы вне зависимости успешно ли наша форма отпраыилась или произошла ошибка.

const test = time => {
  return new Promise((resolve) => {
    setTimeout(() => resolve(), time);
  });
};

// test(1000).then(() => console.log('1000 ms'));
// test(2000).then(() => console.log('2000 ms'));

Promise.all([test(1000), test(2000)]).then(() => {
  console.log('All');
});
// Promise.all() служит для того чтобы мы точно убедились, что все наши Promise`ы уже выполнились. Он ждет выполнения всех Promise`ов и лишь тогда что-то делает.

Promise.race([test(1000), test(2000)]).then(() => {
  console.log('All');
});
// Promise.race() выполняет свои действия как только первый Promise у нас готов, выполнился.

